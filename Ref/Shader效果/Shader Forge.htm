<!DOCTYPE html>
<!-- saved from url=(0049)http://acegikmo.com/shaderforge/nodes/?lang=zh_cn -->
<html eceajbffaaaedafbgaehcddahehcgbfc_i="1"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<script async="" src="./Shader Forge_files/analytics.js"></script><script>

			// JQuery
		    document.write("\<script src='//ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js' type='text/javascript'>\<\/script>");
	


			// Google analytics
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-40853469-2', 'acegikmo.com');
			ga('send', 'pageview');

			var nodeList = new Array();nodeList[0] = "main";
nodeList[1] = "add";
nodeList[2] = "subtract";
nodeList[3] = "multiply";
nodeList[4] = "divide";
nodeList[5] = "power";
nodeList[6] = "sqrt";
nodeList[7] = "log";
nodeList[8] = "min";
nodeList[9] = "max";
nodeList[10] = "abs";
nodeList[11] = "sign";
nodeList[12] = "ceil";
nodeList[13] = "round";
nodeList[14] = "floor";
nodeList[15] = "trunc";
nodeList[16] = "stepaltb";
nodeList[17] = "if";
nodeList[18] = "frac";
nodeList[19] = "fmod";
nodeList[20] = "clamp";
nodeList[21] = "clampsimple";
nodeList[22] = "clamp0-1";
nodeList[23] = "lerp";
nodeList[24] = "lerpsimple";
nodeList[25] = "posterize";
nodeList[26] = "blend";
nodeList[27] = "remap";
nodeList[28] = "remapsimple";
nodeList[29] = "noise";
nodeList[30] = "oneminus";
nodeList[31] = "negate";
nodeList[32] = "exp";
nodeList[33] = "value";
nodeList[34] = "vector2";
nodeList[35] = "vector3";
nodeList[36] = "vector4";
nodeList[37] = "texture2d";
nodeList[38] = "textureasset";
nodeList[39] = "valueproperty";
nodeList[40] = "vector4property";
nodeList[41] = "color";
nodeList[42] = "cubemap";
nodeList[43] = "slider";
nodeList[44] = "dotproduct";
nodeList[45] = "crossproduct";
nodeList[46] = "reflect";
nodeList[47] = "normalize";
nodeList[48] = "append";
nodeList[49] = "componentmask";
nodeList[50] = "desaturate";
nodeList[51] = "channelblend";
nodeList[52] = "normalblend";
nodeList[53] = "distance";
nodeList[54] = "length";
nodeList[55] = "transform";
nodeList[56] = "vectorprojection";
nodeList[57] = "vectorrejection";
nodeList[58] = "panner";
nodeList[59] = "rotator";
nodeList[60] = "parallax";
nodeList[61] = "uvcoordinates";
nodeList[62] = "objectposition";
nodeList[63] = "screenposition";
nodeList[64] = "worldposition";
nodeList[65] = "vertexcolor";
nodeList[66] = "fresnel";
nodeList[67] = "normaldirection";
nodeList[68] = "bitangentdirection";
nodeList[69] = "tangentdirection";
nodeList[70] = "viewdirection";
nodeList[71] = "viewreflection";
nodeList[72] = "lightcolor";
nodeList[73] = "lightattenuation";
nodeList[74] = "ambientlight";
nodeList[75] = "lightdirection";
nodeList[76] = "halfdirection";
nodeList[77] = "lightposition";
nodeList[78] = "time";
nodeList[79] = "viewposition";
nodeList[80] = "projectionparameters";
nodeList[81] = "screenparameters";
nodeList[82] = "scenecolor";
nodeList[83] = "scenedepth";
nodeList[84] = "depthblend";
nodeList[85] = "depth";
nodeList[86] = "pi";
nodeList[87] = "tau";
nodeList[88] = "phigoldenratio";
nodeList[89] = "root2";
nodeList[90] = "eeulersconstant";
nodeList[91] = "sin";
nodeList[92] = "cos";
nodeList[93] = "tan";
nodeList[94] = "arcsin";
nodeList[95] = "arccos";
nodeList[96] = "arctan";
nodeList[97] = "arctan2";
nodeList[98] = "code";
nodeList[99] = "relay";

			function scrollTo(hash) {
			    location.hash = "#" + hash;
			}


			function OnUpdateSearchField(){
				var searchString = document.getElementsByName("searchfield")[0].value.toLowerCase().trim();


				var alwaysShow = true;
				if(searchString.length > 0)
					alwaysShow = false;

				var matchedAny = false;
				for(var i=0;i<nodeList.length;i++){
					if((nodeList[i].indexOf(searchString) != -1) || alwaysShow){
						ShowDiv(nodeList[i]);
						matchedAny = true;
					} else {
						HideDiv(nodeList[i]);
					}
				}

				if(matchedAny){
					HideDiv("search_not_found");
				} else {
					ShowDiv("search_not_found");
				}

			}

			function ShowDiv(id){
				document.getElementById(id).style.display="";
			}

			function HideDiv(id){
				document.getElementById(id).style.display="none";
			}

		</script><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js" type="text/javascript"></script>
		
		

		<!-- Header -->
		<link rel="shortcut icon" type="image/png" href="http://www.acegikmo.com/shaderforge/images/web/favicon_32x32.png">
		<title>Shader Forge</title>
		<!-- CSS -->
		<link rel="stylesheet" type="text/css" href="./Shader Forge_files/styles.css">



	<style id="qb-sougou-search-style" type="text/css">#qb-sougou-search{position:absolute;border-radius:2px;border:1px solid #7f7f7f;border-color:rgba(0,0,0,.5);min-width:105px;background-color:#fff;cursor:default;box-shadow:2px 2px 0 0 rgba(0,0,0,.2);overflow: hidden;z-index:999999;white-space:nowrap;font-family:"Microsoft Yahei","微软雅黑","宋体",Tahoma,Arial,Helvetica,STHeiti;transition:opacity .1s ease-in;-webkit-transition:opacity .1s ease-in;}#qb-sougou-search * {box-sizing:content-box;}#qb-sougou-search iframe {position:absolute;top:0;right:0;border:0;width:100%;height:100%;z-index: -1;opacity:0;filter:alpha(opacity=0);}#qb-sougou-search p {float: left;margin: 0;padding: 4px 14px;height:21px;line-height:21px;color:#474747;font-size:14px;white-space:nowrap;}#qb-sougou-search .last-btn {border-left:1px solid #bfbfbf;}#qb-sougou-search p:hover {background:#efefef;color:#000;}#qb-sougou-search p:before,#qb-sougou-search p:after {display:none;}</style></head>

	<body onload="OnUpdateSearchField()">






		<div class="page_wrapper">

			<div class="main_header">
				<a href="http://acegikmo.com/shaderforge/"><img src="./Shader Forge_files/sf_logo.png"></a>
			</div>

			<div style="display:inline-block;">
				<div class="header_quote">
					<div class="mainpage_quote_body">“You probably won't find a better shader editor in the galaxy kid!”</div><div class="mainpage_quote_author"><a href="http://thomaspasieka.wordpress.com/">Thomas Pasieka</a>, co-creator of The Other Brothers </div>				</div>

				<br>
				<div class="navbar">
					<a class="button" href="http://acegikmo.com/shaderforge/tutorials/">Tutorials</a>
					<a class="button" href="http://acegikmo.com/shaderforge/nodes/">Nodes</a>
					<a class="button" href="http://acegikmo.com/shaderforge/wiki/">Wiki</a>
					<a class="button" href="http://acegikmo.com/shaderforge/faq/">FAQ</a>
					<a class="button" href="http://acegikmo.com/shaderforge/changelog/">Changelog</a>
					<a class="button" href="http://shaderforge.userecho.com/" target="_blank">Feedback</a>

				</div>
			</div>
			<div class="header_separator"></div>

			<!-- <div class="notification_bg"><a href="https://bitly.com/sf_form" class="notification_text">Take a survey - help shape Shader Forge 2!</a></div> -->






<div class="node_desc_header"><div class="search_label">搜索框</div><input type="text" name="searchfield" value="" onchange="OnUpdateSearchField()" onkeyup="OnUpdateSearchField()" onload="OnUpdateSearchField()" onkeydown="OnUpdateSearchField()"><br><div class="node_upper_separator"></div><div class="search_not_found" id="search_not_found" style="display:none;">None of the nodes matched your search :(</div><a href="http://acegikmo.com/shaderforge/nodes/">Eng</a> - <a href="./Shader Forge_files/Shader Forge.htm">简化字</a> - <a href="http://acegikmo.com/shaderforge/nodes/?lang=zh_tw">正體字</a></div><div class="node_list"><div class="node_desc_wrapper" id="main"><div class="node_desc_title">Main （主要）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">这是您的所有其他节点最终将链接到的节点。它拥有为不同目的服务的多个输入。<br>
		以下动画图像显示所有输入及其随时间变化的行为。大部分输入会在 0 和 1（黑色和白色）之间来回绘制动画。<br><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffuse.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse （漫反射）</div><div class="node_desc_main_input_desc">这是着色器的主要颜色。漫反射颜色将根据出光的法线角度接收光线或衰减光线，以及被阴影遮罩。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffusepower.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse Power (漫反射力道)</div><div class="node_desc_main_input_desc">这是光法线角度衰减的指数。可在使用大于 1 的值时获得额外的金属外观。请注意，无论何时启用，它都相当消耗效能。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_specular.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Specular （镜面反射）</div><div class="node_desc_main_input_desc">这是着色器镜面高光的颜色。值越高就越明亮，黑色完全不受着色器影响。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_gloss.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Gloss （光泽）</div><div class="node_desc_main_input_desc">这是镜面高光的指数。值越高光泽度越高，值趋近于 0 时将变得没有光泽。请注意，如果您取消选中光泽重映射，则应避免使用低于 1 的光泽值。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_normal.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Normal （法线）</div><div class="node_desc_main_input_desc">这是切线空间法线方向，您可在此连接法线贴图或自定义法线向量。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_emission.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Emission （自发光）</div><div class="node_desc_main_input_desc">这是无论光照条件如何始终都会添加到着色器的光线。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_transmission.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Transmission （透射）</div><div class="node_desc_main_input_desc">此选项在光源位于当前渲染的表面背后时控制有多少光线可以通过。这对于薄型材料十分有用，例如布料或植被。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_lightwrapping.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Light Wrapping （环绕光）</div><div class="node_desc_main_input_desc">这是控制出光法线角度衰减偏移的一种方法，可用于获得与次表面散射相似的效果。对于平滑对象最有用。输入偏红色的值将让红色通道比其他通道更多地“环绕”对象，这样看起来就像是光线传递到网格中并携带红色波长出来，与遮罩皮肤的方法类似。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffuseambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse Ambient Light （漫反射环境光）</div><div class="node_desc_main_input_desc">此选项将光线添加到着色器，受漫反射影响。可以与立方体贴图（使用基于图像的光照 (IBL) 的法线方向）或环境光等一起使用</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_specularambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Specular Ambient Light （镜面反射环境光）</div><div class="node_desc_main_input_desc">此选项将光线添加到着色器，受镜面反射影响。可以与立方体贴图（使用基于图像的光照 (IBL) 的视图反射方向）等一起使用</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_diffuseambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Diffuse Ambient Occlusion （漫反射环境光遮蔽）</div><div class="node_desc_main_input_desc">此选项抑制间接漫反射光线，例如光探头、间接光线和漫反射环境光</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_specularambientlight.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Specular Ambient Occlusion （镜面反射环境光遮蔽）</div><div class="node_desc_main_input_desc">此选项可抑制间接镜面反射光线，例如反射探头和镜面反射环境光</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_customlighting.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Custom Lighting （自定义照明）</div><div class="node_desc_main_input_desc">此输入在着色器设置为不打光时处于活动状态，可让您定义自定义照明行为。您在此处根据光线放置节点。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_alpha.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Opacity （不透明度）</div><div class="node_desc_main_input_desc">Opacity（不透明度）控制最终像素的透明度。请注意，部分透明度通常很难设置正确，特别是在使用延迟渲染时。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_alphaclip.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Opacity Clip （不透明度剪切）</div><div class="node_desc_main_input_desc">Opacity Clip（不透明度剪切）是控制是否应该绘制当前像素/片段的一种方法。始终对需要透明度的对象使用硬剪切，但不要对部分透明度使用硬剪切，因为 Opacity Clip（不透明度剪切）可以轻松排序，但是 Opacity（不透明度）不可以。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_refraction.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Refraction （反射）</div><div class="node_desc_main_input_desc">Refraction（反射）是用于折射背景像素的屏幕空间 UV 偏移。请确保在使用前将 Opacity（不透明度）设置为低于 1 的值，以便折射效果可见。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_outlinewidth.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Outline Width （描边宽度）</div><div class="node_desc_main_input_desc">此选项将向着色器添加描边，渲染为具有反面法线的偏移网格。请注意，硬边将损坏描边。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_outlinecolor.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Outline Color （描边颜色）</div><div class="node_desc_main_input_desc">此选项控制描边的颜色。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_vertexoffset.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">Vertex Offset （顶点偏移）</div><div class="node_desc_main_input_desc">此选项可用于随时间变化对着色器进行动画，或在不同条件下更改对象的形状。您只需插入每个顶点所需偏移量的 XYZ 坐标即可。</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_displacement.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">DX11 Displacement （DX11 位移）</div><div class="node_desc_main_input_desc">此选项和 Vertex Offset（顶点偏移）的作用非常类似，但是与 DX11 曲面细分一起使用。（请注意，DirectX 仅适用于 Windows，需要 DX11 GPU 且必须在 Unity 设置中启用）</div></div></div><br>
		<div class="node_desc_main_input"><div class="node_desc_inner_img"><img src="./Shader Forge_files/main_input_tessellation.gif"></div><div class="node_desc_main_input_right"><div class="node_desc_main_input_title">DX11 Tessellation （DX11 曲面细分）</div><div class="node_desc_main_input_desc">此选项控制您要将三角形分割为多少个细分。（请注意，DirectX 仅适用于 Windows，需要 DX11 GPU 且必须在 Unity 设置中启用）</div></div></div><br>
		</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="add"><div class="node_desc_title">Add (加法)<div class="node_desc_title_hotkey"> A + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_add.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] + [B] 之和</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="subtract"><div class="node_desc_title">Subtract (减法)<div class="node_desc_title_hotkey"> S + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_subtract.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] - [B] 之差</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="multiply"><div class="node_desc_title">Multiply (乘法)<div class="node_desc_title_hotkey"> M + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_multiply.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] * [B] 之积</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="divide"><div class="node_desc_title">Divide (除法)<div class="node_desc_title_hotkey"> D + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_divide.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] / [B] 之商</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="power"><div class="node_desc_title">Power (乘方)<div class="node_desc_title_hotkey"> E + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_power.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [Val] ^ [Exp] 之幂</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="sqrt"><div class="node_desc_title">Sqrt (平方根)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的平方根</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="log"><div class="node_desc_title">Log (对数)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的对数。您可以在下拉菜单中切换对数底</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="min"><div class="node_desc_title">Min (最小值)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_min.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] 和 [B] 的最小值</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="max"><div class="node_desc_title">Max (最大值)</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_max.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] 和 [B] 的最大值</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="abs"><div class="node_desc_title">Abs （绝对值）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_abs.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的绝对值。它实质上让负值变为正值</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="sign"><div class="node_desc_title">Sign （正负零取值）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_sign.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的符号。<br>
		值大于 0 时输出 1<br>
		值等于 0 时输出 0<br>
		值小于 0 时输出 -1</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ceil"><div class="node_desc_title">Ceil （进位取整）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_ceil.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出时将其输入向上舍入为最近整数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="round"><div class="node_desc_title">Round （四舍五入取整）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_round.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出时将其输入四舍五入为最近整数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="floor"><div class="node_desc_title">Floor （舍位取整）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_floor.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出时将其输入向下舍入为最近整数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="trunc"><div class="node_desc_title">Trunc （取整）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_trunc.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出时将其输入向零四舍五入到最近整数。它实质上去掉小数，留下整数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="stepaltbaltb"><div class="node_desc_title">Step (A &lt;= B) （比较 (A &lt;= B)）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_step.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">如果 [A] 小于或等于 [B]，则输出 1，否则输出 0</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="if"><div class="node_desc_title">If （条件）<div class="node_desc_title_hotkey"> I + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">[A] 大于 [B] 时，输出 [A&gt;B] 输入<br>
		[A] 等于 [B] 时，输出 [A=B] 输入<br>
		[A] 小于 [B] 时，输出 [A&lt;B] 输入</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="frac"><div class="node_desc_title">Frac （取小数）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_frac.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的小数部分。它实质上移除整数部分，仅保留小数部分。如果输入为 4.32，则会输出 0.32。此节点在与 Time（时间）节点一起使用时非常有用，会随时间变化带来锯齿波</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="fmod"><div class="node_desc_title">Fmod （取模）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] 除以 [B] 的余数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="clamp"><div class="node_desc_title">Clamp （范围）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其主输入的值，不小于 [Min] 且不大于 [Max]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="clampsimple"><div class="node_desc_title">Clamp (Simple) （范围（简单））</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">跟 Clamp（范围）一样，但为最小值和最大值使用数字输入，而不使用节点接口</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="clamp0-10-1"><div class="node_desc_title">Clamp 0-1 （范围 0-1）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_clamp01.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入值，不小于 0 且不大于 1</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lerp"><div class="node_desc_title">Lerp （线性插值）<div class="node_desc_title_hotkey"> L + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lerp.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">Lerp（线性插值）用于混合两个值或颜色。<br>
		如果 [T] 为 0，则将输出 A<br>
		如果 [T] 为 0.5，则将输入 [A] 和 [B] 的分半混合<br>
		如果 [T] 为1，则将输出 B<br>
		如果 [T] 为两者间的任一值，则将输入两者的线性混合。</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lerpsimple"><div class="node_desc_title">Lerp (Simple) （线性插值（简单））</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">与 Lerp（线性插值）一样，但为 [A] 和 [B] 使用数字输入，而不使用节点接口</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="posterize"><div class="node_desc_title">Posterize （色调分离）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_posterize.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">基于经过 [Steps] 的值对值进行四舍五入取整。[Steps] 值为 5 时将在 0 到 1 的范围内创建 5 段</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="blend"><div class="node_desc_title">Blend （混合）<div class="node_desc_title_hotkey"> B + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_blend.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">使用指定方法混合 [A] 和 [B]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="remap"><div class="node_desc_title">Remap （重映射）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_remaprangeadvanced.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">将值从一个范围重映射到另一个范围。与 Remap (Simple)（重映射（简单））一样，但使用输入而不是数值常数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="remapsimple"><div class="node_desc_title">Remap (Simple) （重映射（简单））<div class="node_desc_title_hotkey"> R + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_remaprange.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">将值从一个范围重映射到另一个范围。例如，如果节点期望 -1 到 1 的值，但您想要它输出 2 到 5 的值，那么您可以在第一行键入-1 和 1，在第二行键入 2 和 5</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="noise"><div class="node_desc_title">Noise （噪波）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_noise.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">根据两分量输入（例如 UV 坐标）生成伪随机点</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="oneminus1"><div class="node_desc_title">One Minus （1 减）<div class="node_desc_title_hotkey"> O + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_oneminus.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 1 减去其输入。与颜色输入一起使用时，将反转颜色</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="negate"><div class="node_desc_title">Negate （取反）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_negate.jpg"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其主输入乘以 -1。实质上让正值变负，让负值变正</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="exp"><div class="node_desc_title">Exp （指数）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">选定 Exp（指数）时：输出 e 到其输入的幂<br>
		选定 Exp 2（指数 2）时：输出 2 到其输入的幂</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="value"><div class="node_desc_title">Value （值）<div class="node_desc_title_hotkey"> 1 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">数字值，也可称为“Vector 1”（向量 1）。还提供属性版本。值可以与 Append（附加）节点一起用于创建拥有多个分量的向量。值还可以与向量/颜色相乘。例如，向量 (3,1,0) 乘以 0.5 会输出向量 (1.5,0.5,0)</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector22"><div class="node_desc_title">Vector 2 （向量 2 ）<div class="node_desc_title_hotkey"> 2 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">具有两个分量/值的向量。通常与 UV 坐标一起使用。将 Vector 2（向量 2） 添加到 UV 坐标会转换 UV 坐标。将 UV 坐标与 Vector 2（向量 2）相乘会缩放 UV</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector33"><div class="node_desc_title">Vector 3 （向量 3 ）<div class="node_desc_title_hotkey"> 3 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">具有三个分量/值的向量。通常用作颜色、位置或方向</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector44"><div class="node_desc_title">Vector 4 （向量 4 ）<div class="node_desc_title_hotkey"> 4 + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">具有四个分量/值的向量。通常用作具有 Alpha 通道的颜色，或用作在第四个通道中有一些额外数据的位置。检视器中有两个参数可供曝光。Color（颜色）和 Vector 4（向量 4）参数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="texture2d2d"><div class="node_desc_title" style="color:#53b19c;">Texture 2D （2D 纹理）<div class="node_desc_title_hotkey"> T + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tex2d.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">包含对纹理的引用，并将使用特定 MIP 级别在特定 UV 坐标上对纹理进行采样（如果已连接）。如果 [Tex] 输入由 Texture Asset（纹理资源）节点连接，则它将不再是检视器中的参数。输出 [RGB] 以及单独的通道</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="textureasset"><div class="node_desc_title" style="color:#53b19c;">Texture Asset （纹理资源）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tex2dasset.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">包含对纹理的引用。用于对单个纹理进行多次采样 – 仅可连接到 Texture 2D（2D 纹理）节点的 [Tex] 输入。这也将在材质的检视器中反映出来，因此用户只需要分配一个纹理</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="valueproperty"><div class="node_desc_title" style="color:#53b19c;">Value (Property) （值（属性））</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">数字值；与 Value（值）一样，但在材质检视器中曝光</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vector4property4"><div class="node_desc_title" style="color:#53b19c;">Vector 4 (Property) （向量 4（属性））</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">具有四个分量/值的向量，与 Vector 4（向量 4）一样，但在材质检视器中作为 4 个单独的 X、Y、Z 和 W 值曝光</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="color"><div class="node_desc_title" style="color:#53b19c;">Color （颜色）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">具有四个分量/值的向量，与 Vector 4（向量 4）一样，但在材质检视器中作为取色器曝光</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="cubemap"><div class="node_desc_title" style="color:#53b19c;">Cubemap （立方体贴图）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">包含对立方体的引用，并将使用特定 MIP 级别在特定方向对其进行采样（如果已连接）。输出 [RGB] 以及单独的通道</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="slider"><div class="node_desc_title" style="color:#53b19c;">Slider （滑动条）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">让您能够轻松地在最小值和最大值之间调整某个值。也向检视器曝光</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="dotproduct"><div class="node_desc_title">Dot Product （点积）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] 和 [B] 之间的点积。对于两个归一化的向量而言，它实质上输出两个向量指向之间的距离。如果它们指向相同方向，则输出 1；如果它们互相垂直，则输出 0；如果它们指向相反方向，则输出 -1。<br>
		下拉选择：<br>
		标准 – 常规点积<br>
		正数 – 让所有负值为 0<br>
		负数 – 让所有正值为 0<br>
		绝对值 – 让所有负值为正<br>
		归一化 – 在 0 到 1（而不是 -1 到 1）的范围内输出<br>
		<br>
		下图显示使用两个归一化向量时不同模式的行为。<br>
		在 X 轴上可以得到其夹角，在 Y 轴上可以得到输出值：<br>
		<img src="./Shader Forge_files/sfn_dot.jpg"></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="crossproduct"><div class="node_desc_title">Cross Product （叉积）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 [A] 和 [B] 的叉积。它实质上输出垂直于两个输入向量的向量</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="reflect"><div class="node_desc_title">Reflect （反射）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出入射向量 [I] 的反射向量，就像在具有法线 [N]  的表面上反射/反弹一样</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="normalize"><div class="node_desc_title">Normalize （归一化）<div class="node_desc_title_hotkey"> N + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出输入向量的归一化版本。实质上将向量长度设置为 1，并保持相同方向</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="append"><div class="node_desc_title">Append （附加）<div class="node_desc_title_hotkey"> Q + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_append.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">从多个输入值/向量输出单个向量。例如，如果 [A] 是向量 2，[B] 是 Value (Vector 1)（值（向量 1）），则节点将输出 Vector 3（向量 3），其中 [A] 在红色和绿色通道中，而 [B] 在蓝色通道中</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="componentmask"><div class="node_desc_title">Component Mask （分量遮罩）<div class="node_desc_title_hotkey"> C + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_componentmask.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">分量遮罩可用于重新排序或提取向量的通道</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="desaturate"><div class="node_desc_title">Desaturate （去色）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_desaturate.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出输入 [Col] 的去色版本。[Des] 确定去色程度。值为 1 表示完全去色，值为 0.5 表示半去色，值为 0 表示不去色</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="channelblend"><div class="node_desc_title">Channel Blend （通道混合）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_channelblend.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出遮罩的每个分量乘以对应颜色输入后的和。对于三平面混合十分有用</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="normalblend"><div class="node_desc_title">Normal Blend （法线混合）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">合并两个法线方向，其中基础法线被细节法线扰乱</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="distance"><div class="node_desc_title">Distance （距离）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_distance.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出两个输入点 [A] 和 [B] 之间的距离</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="length"><div class="node_desc_title">Length （长度）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_length.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入向量的长度/幅度</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="transform"><div class="node_desc_title">Transform （转换）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">将向量从一个空间转换到另一个空间。您可以在世界/本地/切线/视图之间切换。内置向量在世界空间中。法线输入的方向在切线空间中。</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vectorprojection"><div class="node_desc_title">Vector Projection （向量投影）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出向量 [A] 到向量 [B] 的投影</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vectorrejection"><div class="node_desc_title">Vector Rejection （向量拒识）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出从向量 [B] 拒识的向量 [A]</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="panner"><div class="node_desc_title">Panner （平移器）<div class="node_desc_title_hotkey"> P + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出输入 [UV] 坐标，按 [Dist] 距离，以 U 参数和 V 参数指定的方向/速度进行平移/偏移</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="rotator"><div class="node_desc_title">Rotator （旋转器）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_rotator.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出输入 [UV] 坐标，绕轴心点 [Piv] 按 [Ang] 弧度旋转。如果 [Ang] 未连接或连接到时间节点，[Spd] 将控制旋转速度</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="parallax"><div class="node_desc_title">Parallax （视差）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出输入 [UV] 坐标，具有从 [Hei] 输入派生的视差偏移，深度为 [Dep]，引用高度为 [Ref]。<br>
		[Ref] 高度为 0 表示其视差效果为高度贴图看似从网格中突出<br>
		[Ref] 高度为 1 表示其视差效果为高度贴图看似向下进入网格中<br></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="uvcoordinatesuv"><div class="node_desc_title">UV Coordinates （UV 坐标）<div class="node_desc_title_hotkey"> U + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出几何图形该部分的指定 UV 坐标。下拉选择可让您选择 UV 通道 0 或 UV 通道 1。请注意，光照贴图网格为其光照贴图 UV 使用 UV1</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="objectposition"><div class="node_desc_title">Object Position （对象位置）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_objectposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出对象轴心点的世界位置</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="screenposition"><div class="node_desc_title">Screen Position （屏幕位置）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_screenpos.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出网格当前部分的屏幕位置，可在屏幕空间贴图时用作 UV 坐标。在下拉框中，“Normalized”（归一化）会将 {0,0} 放在屏幕中心，将 {1,1} 放在右上方。“Tiled”（平铺）也会将 {0,0} 放在中心，但将根据纵横比在 X 轴上缩放</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="worldposition"><div class="node_desc_title">World Position （世界位置）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_fragmentposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">在世界空间中输出网格当前部分的位置</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="vertexcolor"><div class="node_desc_title">Vertex Color （顶点颜色）<div class="node_desc_title_hotkey"> V + LMB</div></div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_vertexcolor.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出顶点颜色。如果您在顶点颜色中烘焙了环境光遮蔽，或要使用喷涂颜色为网格染色，或要将顶点颜色用于其他对象，那么这就是您需要的节点</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="fresnel"><div class="node_desc_title">Fresnel （菲涅尔）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_fresnel.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出表面法线和视图方向之间的点积。如果想要使用自定义法线，则会使用 [Nrm]。默认使用扰乱法线。[Exp] 更改输出的指数。值越高，菲涅尔越薄。</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="normaldirection"><div class="node_desc_title">Normal Direction （法线方向）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_normalvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">在世界空间中输出网格法线的方向。Perturbed（扰乱）复选框使其在应用 Main（主要）节点的“Normal”（法线）输入后使用法线，例如法线贴图。</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="bitangentdirection"><div class="node_desc_title">Bitangent Direction （双切线方向）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_binormal.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">在世界空间中输出网格双切线的方向</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="tangentdirection"><div class="node_desc_title">Tangent Direction （切线方向）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tangent.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">在世界空间中输出网格切线的方向</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="viewdirection"><div class="node_desc_title">View Direction （视图方向）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_viewvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">在世界空间中输出从几何图形当前部分到摄像机的方向</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="viewreflection"><div class="node_desc_title">View Reflection （视图反射）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_viewreflectionvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出视图的方向，就像根据表面法线反弹那样。这可用作完美反射的立方体贴图的输入</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightcolor"><div class="node_desc_title">Light Color （光色）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightcolor.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输入当前要渲染的光线的颜色</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightattenuation"><div class="node_desc_title">Light Attenuation （光线衰减）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightattenuation.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出光线衰减。此节点同时包含光线衰减和阴影</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="ambientlight"><div class="node_desc_title">Ambient Light （环境光）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_ambientlight.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出要在其中渲染着色器的场景的环境光</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightdirection"><div class="node_desc_title">Light Direction （光线方向）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出当前要渲染的光线的方向</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="halfdirection"><div class="node_desc_title">Half Direction （折半方向）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_halfvector.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出折半方向。这是指向视图和光线向量中间的方向，通常在 blinn-phong 镜面反射模型中使用</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="lightposition"><div class="node_desc_title">Light Position （光线位置）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_lightposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出当前要渲染的光线的位置。<br>[Pnt] 如果当前要渲染的光线是点光线，则输出 1，否则输出 0</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="time"><div class="node_desc_title">Time （时间）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_time.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">以不同速率输出时间。<br>
		[t/20] 以 1/20 倍速率输出时间<br>
		[t] 输出当前时间<br>
		[t*2] 以 2 倍速率输出时间<br>
		[t*3] 以 3 倍速率输出时间</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="viewposition"><div class="node_desc_title">View Position （视图位置）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_viewposition.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出视图/摄像机的当前位置（请注意，使用透视摄像机时，视图位置在屏幕“背后”）</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="projectionparameters"><div class="node_desc_title">Projection Parameters （投影参数）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_projectionparameters.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出四个投影参数。<br>
		[Sign] 为 -1，如果当前使用倒装投影矩阵渲染，否则为 1<br>
		[Near] 是当前摄像机的近平面距离<br>
		[Far] 是当前摄像机的远平面距离<br>
		[1/Far] 是远平面距离的倒数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="screenparameters"><div class="node_desc_title">Screen Parameters （屏幕参数）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_screenparameters.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出四个屏幕参数。<br>
		[pxW] 是以像素为单位的屏幕宽度<br>
		[pxH] 是以像素为单位的屏幕高度<br>
		[1+1/W] 是 1 加像素宽度的倒数<br>
		[1+1/H] 是 1 加像素高度的倒数</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="scenecolor"><div class="node_desc_title">Scene Color （场景颜色）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">包含渲染此对象前的场景渲染的纹理。默认其 UV 位于屏幕空间中，从而让每个像素都代表对象背后的颜色。这可用于更加高级的混合/透明度效果，或作为 UV 改变时形成折射的其中一种手动方法</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="scenedepth"><div class="node_desc_title">Scene Depth （场景深度）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">摄像机到当前像素背后的场景的深度。您需要在混合设置中关闭深度缓冲编写, <a href="http://docs.unity3d.com/Documentation/Components/SL-CameraDepthTexture.html">并且需要使用渲染深度纹理的摄像机</a></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="depthblend"><div class="node_desc_title">Depth Blend （深度混合）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">它根据距离输入输出 0 和 1 之间的值，具体取决于此像素距背景几何图形多近。对于水边缘的淡出或光轴相交几何图形的软化很有用。注意：您需要在混合设置中关闭深度缓冲编写，<a href="http://docs.unity3d.com/Documentation/Components/SL-CameraDepthTexture.html">并且需要使用渲染深度纹理的摄像机</a></div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="depth"><div class="node_desc_title">Depth （深度）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">这是摄像头近平面到对象的距离</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="pipi"><div class="node_desc_title">Pi （π，Pi）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_pi.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 π 的值，圆的周长与直径的比值（约为 3.141593）</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="tautau"><div class="node_desc_title">Tau （τ，Tau）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_tau.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 τ 的值，圆的周长与半径的比值（约为 6.283185）</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="phigoldenratiophi"><div class="node_desc_title">Phi (Golden ratio) （φ，Phi（黄金比例））</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_phi.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 φ 的值，黄金比例（约为 1.618034）</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="root22"><div class="node_desc_title">Root 2 （√2）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_root2.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出 2 的算术平方根（约为 1.414214）</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="eeulersconstante"><div class="node_desc_title">e (Euler's Constant) （e，欧拉常数）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_e.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出欧拉常数e（约为 2.718282）</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="sin"><div class="node_desc_title">Sin （正弦）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的正弦</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="cos"><div class="node_desc_title">Cos （余弦）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的余弦</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="tan"><div class="node_desc_title">Tan （正切）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入的正切</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arcsin"><div class="node_desc_title">ArcSin （反正弦）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">以弧度输出其输入的反正弦</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arccos"><div class="node_desc_title">ArcCos （反余弦）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">以弧度输出其输入的反余弦</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arctan"><div class="node_desc_title">ArcTan （反正切）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">以弧度输出其输入的反正切</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="arctan2"><div class="node_desc_title">ArcTan2 （双变量反正切）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_arctan2.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">以弧度输出其两个输入的反正切。ArcTan2 输出介于 –π 和 π 之间的特定角度</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="code"><div class="node_desc_title">Code （代码）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_code.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">用于在着色器内部执行自定义代码的节点。在左侧的示例中，节点与线性插值的工作方式类似，在到达 [end] 之前向 [mid] 弯曲</div></td></tr></tbody></table></div></div></div><div class="node_desc_wrapper" id="relay"><div class="node_desc_title">Relay （中继）</div><div class="node_desc"><div class="node_desc_inner"><table><tbody><tr><td><div class="node_desc_inner_img"><img src="./Shader Forge_files/sfn_relay.png"></div></td><td style="vertical-align: top;"><div class="node_desc_inner_txt">输出其输入，对于组织节点连接十分有用</div></td></tr></tbody></table></div></div></div></div>		



		<div class="footer">
			Shader Forge © Joachim 'Acegikmo' Holmér<br>
			webmaster@acegikmo.com
		</div>



		</div>
	
<div id="qb-sougou-search" style="display: none; opacity: 0; left: 600px; top: 525px;"><p>搜索</p><p class="last-btn">复制</p><iframe src=""></iframe></div></body></html>